GAMS 48.6.1  67fbb04b Jan 23, 2025          WEX-WEI x86 64bit/MS Windows - 01/31/25 20:32:35 Page 1
A branch and bound problem
C o m p i l a t i o n


   4  *cnstr_15 and cnstr_19 are infeasible and I hypothesize it's due to not setting initial virtual positions!
   5   
   6  !!longest qc operation (or job in the problem)
  10  !! The default number of qcs and blocks are set to 3 and 6. Therefore AL and AR each should have 12 members. I think the capacity of each block is 5 (bc of number of HPs)
  11  !! However, for the first experiment:
  12  !! blcoks = 4, QC = 3, AGVs = 3, containers = 7, ships = 3
  13  Scalars
  14   
  15          S_Q "switch time for qc between two containers" /2/ !! temporarily assumed constant (take look at 6.1 and qc_double_cycle.svg)
  16          v "AGV speed" /4/
  17          Mnum "a very large number" /10000000/;
  18   
  19   
  20  Sets
  21          i "index" /i0*i3/
  22          i1(i) /#i/
  23          j(i) "a duplicate of i" /#i/ !!this is temporary, a better is to write /#i/
  24   
  25          m   "QC index" /m0, m1, m2, m3/
  26          n(m)   "A duplicate of j" /#m/ !!this is temporary, a better is to write /#m/
  27   
  28          L(m,i)   /m1.i1, m2.i2, m3.i2/ !! these are stored in ASC storage area, waiting to be placed in the ship by the QC
  29          D(m,i) "Unloading Containers. U is a subset of index i" /m1.i2, m2.i1, m3.i1, m3.i3/ !! these are in the ships, waiting to be taking to ASCs
  30   
  31          C(m,i)  "All  Containers" /m1.i1, m1.i2, m2.i1, m2.i2, m3.i1, m3.i2, m3.i3/ !! this is in data file, this should contain 0 node, too!
  32          Cd(m,i) "the last QC container job for all QCs" /m1.i2, m2.i2, m3.i3/
  33   
  34          li "AGV index" /l1*l2/
  35          Bs(li) "set of all agvs" /#li/
  36          a   "AGV actions" /a0*a4/
  37          !! Below is written according to Fig 5. of base article
  38          WT(m,i,a) "set of total actions with virtual node" /#C.(a1,a2,a3,a4)/
  39          WV(m,i,a)  "Vertical Actions" /#C.a2/ !! those containing a2. Note that this set includes all the containers (m,i) in C(m,i)
  40          WH(m,i,a)  "Horizontal Actions" /#D.(a1,a3,a4), #L.(a1,a3,a4)/ !! those containing a1,a3,a4. Be sure to include virtual a0 in it.
  41   
  42  *********************************************
  43  *Location based sets
  44          XR (*)  "Vertical Operational Area" /1*23/
  45   
  46  ******************** First Experminent
  47  *        YR (*) "Horizontal Operational Area" /1*23/
  48  *        YS(YR)  "Horizontal Seaside Operation Area" /12*23/
  49  *        YL(YR)  "Horizontal Path" /1*11/
  50  **********************
  51   
  52  *2nd experiment
  53          YR (*) "Horizontal Operational Area" /1*10/
  54          YS(YR)  "Horizontal Seaside Operation Area" /6*10/
  55          YL(YR)  "Horizontal Path" /1*5/
  56   
  57  !! what o(m,i,XR) basically determines is location of storage blocks on the ship. (How many ships are there)
  58  *        o(m,i,XR) / m1.i1.3,
  59  *                    m1.i2.5,
  60  *                    m2.i1.11,
  61  *                    m2.i2.13,
  62  *                    m3.i1.17,
  63  *                    m3.i2.19,
  64  *                    m3.i%d3%.21/
  65          o(m,i,XR) / m1.i1.3,
  66                      m1.i2.3,
  67                      m2.i1.11,
  68                      m2.i2.11,
  69                      m3.i1.17,
  70                      m3.i2.17,
  71                      m3.i3.17/
  72   
  73  *!!these sets refers right and left positions of the blocks in the fig. 4 of the article. These two are related to the L(m,i). Positions of the block storing (m,i). (which is totally a wrong statement, it should contain membs of D(m,i), too!)
  74          A_L_set(XR) /1,7,13,19/
  75          A_R_set(XR) /5,11,17,23/
  76          A_L(m,i,XR) /#C.#A_L_set/
  77          A_R(m,i,XR) /#C.#A_R_set/
  78   
  79   
  80  !! Maybe Badly Put! Needs fixing! In the data file!
  81          psi_1(m,i,m,i)   "sequence of Container jobs for QC" /m1.i1.m1.i2, m2.i1.m2.i2, m3.i1.m3.i2, m3.i2.m3.i3 /
  82          psi_2(m,i,m,i)   "sequence of Container jobs for ASC" /m2.i2.m3.i2 / !!This is in data file. (m,i) and (m,i) belong to the same block!
  83          ;
  84  parameter o1(m,i) "Merely a copy of the o(m,i,XR), with XR treated as a number"/
  85                  m1.i1 3,
  86                  m1.i2 3,
  87                  m2.i1 11,
  88                  m2.i2 11,
  89                  m3.i1 17,
  90                  m3.i2 17,
  91                  m3.i3 17/
  92   
  93  *****************************************************************************************************************
  94  *Dupilcates of the some of the sets!
  95  alias (XR, XR1);
  96  alias (XR, XR_1);
  97  alias (YR, YR_1);
  98  alias (a,a1);
  99  alias (a,a2);
 100  alias (a2,a2_1);
 101  alias (a1,a1_1);
 102  *alias (i,i1);
 103  set h(m)/#m/;  !! for cnstr_3
 104  set k(i) /#i/;
 105  set s(YR);
 106  set XR2(XR) /#XR/;
 107  set x_t(XR) /#XR/;
 108  *****************************************************************************************************************
 109   
 110  Parameters
 111   
 112          G_Q(m,i) /#C 40/ !! seems to be constant for all container jobs, bc of const 24. Which shouldn't make sense because of def of ADRP!!!
 113          G_Y(m,i) /#C 40/
 114          ;
 115  *****************************************************************************************************************
 116   
 117  Binary Variables
 118          z(m, i, m, i, li)   "used mainly for handling QC double cycling, it consists of 0 virtual point!" !! (m,i) and (m,i) are NOT equal, TOO!
 119          U_AGV(m,i,a,m,i,a)  "U_AGV(j_1,j_2) conducted before" !! note that (m,i,a) and (m,i,a) are NOT equal!!
 120          U_QC(m,i,m,i,a)   "U_QC(j,WT) conducted before"
 121   
 122  *       Path related variables
 123          P_X(m,i,a,XR) "P_X(WV,x) finish V loc, These are defined on actions, NOT ON CONTAINERS!"
 124          P_Y(m,i,a,YR) "P_Y(WH,y) finish H loc, These are defined on actions, NOT ON CONTAINERS!"
 125          P_X0(m,i,a,XR) "P_X(WV,x) Start H  loc, These are defined on actions, NOT ON CONTAINERS!"
 126          P_Y0(m,i,a,YR) "P_Y(WH,y) Start H loc, These are defined on actions, NOT ON CONTAINERS!"
 127          ;
 128  *****************************************************************************************************************
 129  Positive Variables
 130  *       Time related variables
 131          T_Q(m,i) "start time of QC"
 132          T_Y(m,i) "Start time of agv putting cont on ASC"
 133          T_start(m,i,a) "Start of agv for action (m,i,a)"
 134          CT(m,i)  "Op. completion time of for each QC m"
 135   
 136  *       Auxiliary Variables
 137          t_AGV(m,i,a,m,i,a)        "t_AGV(WT_1,WT_2"
 138          X_position(m,i,a)   "X_position(WT)"
 139          Y_position(m,i,a)   "Y_position(WT)"
 140          ;
 141  variable obj "objective function";
 142  *****************************************************************************************************************
 143   
 144  Equations
 145   
 146          ADRP                       "AGV Dispatching and Routing Problem"
 147          LJob(m,i)
 148   
 149  *       Job assignment constraints
 150          cnstr_2(m,i)
 151          cnstr_3(m,i,li)             "C,B"
 152          cnstr_4(li)                 "B with 0 virtual node"
 153          cnstr_5(li)               â€Œ  "B with 0 virutal node"
 154          cnstr_6(m,i)                "L"
 155          cnstr_7(m,i)                "D"
 156  **********************************************************************
 157  *       Location constraints of AGV acitons
 158  *        cnstr_8(m,i,n,j,XR)         "C,C,XR"
 159  *        cnstr_8_slack(m,i,n,j)
 160          cnstr_8(m,i,n,j,xr)
 161          cnstr_8_1(m,i,n,j,xr)
 162          cnstr_9(m,i,n,j,YR)         "C,C,YR"
 163          cnstr_9_1(m,i,n,j,YR)         "C,C,YR"
 164          cnstr_10(m,i,a)             "C,a"
 165          cnstr_11(m,i,a)             "C,a"
 166          cnstr_12(m,i)               "L"
 167          cnstr_13(m,i)               "D"
 168          cnstr_14(m,i,XR)            "D"
 169          cnstr_15(m,i)               "L"
 170          cnstr_19(m,i)               "D"
 171          cnstr_16(m,i)               "D"
 172          cnstr_17(m,i)               "L"
 173          cnstr_18(m,i,XR)            "L"
 174          cnstr_20(m, i, a, a, YR)    "WH,YR"
 175          cnstr_21(m,i,a,a,XR)        "WV,XR"
 176   
 177  **********************************************************************
 178  *       Conflict Free Constraints
 179          cnstr_22(m,i,n,j)           "C,C"
 180          cnstr_23(m,i,a,n,j,a,YR,XR, a, a) "WH,WH,YR,XR" !!Look How many equations it would add to the model
 181          cnstr_24(m,i,n,j,a)         "C, WH"
 182          cnstr_25(m,i,n,j,a,a)       "C, WH"
 183          cnstr_26(n,j,a,YS,m,i,a,a)  "WH,YS,D"
 184          cnstr_27(m,i,a,n,j,a,XR)    "WV, XR"
 185          cnstr_28(m,i,a, a)          "C,a"
 186  **********************************************************************
 187  ****Time Constraints
 188          cnstr_29(m,i,i)             "C,C"      !! two consecutive containers, i and i+1
 189          cnstr_30(m,i,m,i)           "psi_1"
 190          cnstr_31(m,i,m,i)           "psi_2"
 191          cnstr_32(m,i)               "D"
 192          cnstr_33(m,i)               "L"
 193          cnstr_34(m,i,m,i)           "D,L"
 194          cnstr_35(m,i,m,i)           "L,D"
 195          cnstr_36(m,i,a)             "D,a"
 196          cnstr_37(m,i,a)             "D,a"
 197          cnstr_38(m,i,a,a,n,j,a)     "WT,WT"
 198          cnstr_39(m,i,a,XR)          "C,a,XR"
 199          cnstr_39_1(m,i,a,XR)          "C,a,XR"
 200          cnstr_40(m,i,a,YR)          "C,a,YR"
 201          cnstr_40_1(m,i,a,YR)          "C,a,YR"
 202          cnstr_41(m,i,a,m,i,a)
 203          ;
 204   
 205  **********************************************************************
 206  *This determines whether the last container job is for QC or AGV
 207  LJob(Cd).. CT(Cd) =e= max(T_Q(Cd)+G_Q(cd), T_Y(Cd)+G_Y(Cd));
 208  *This constraint clarifies the lengthiest operation among all container jobs
 209  ADRP.. obj  =e= smax(Cd, CT(Cd));
 210   
 211  *****************************************************************************************************************
 212  **Job assinment constraints
 213  *as soon as you include conditional $(C(m,i)), you ignore virtual node!
 214  *there are many actions, having a0 as their starting. a0 is not in the formulation in the article
 215  cnstr_2(m,i) $(C(m,i)).. sum((li,n,j) $((C(n,j) and (not sameas(m,n) or not sameas(i,j))) or (sameas(n,'m0') and sameas(j, 'i0'))),  z(m,i,n,j,li)) =e= 1 ;
 216   
 217  cnstr_3(m,i,li) $(C(m,i))..sum((n,j) $((C(n,j)and (not sameas(m,n) or not sameas(i,j))) or (sameas(n,'m0') and sameas(j, 'i0'))), z(n,j,m,i,li)) -sum((h,k) $(C(h,k) or (sameas(h,'m0') and sameas(k,'i0'))), z(m,i,h,k,li)) =e= 0;
 218   
 219  cnstr_4(li).. sum((m,i) $(C(m,i)), z('m0', 'i0', m, i, li))=e= 1;
 220  cnstr_5(li).. sum((m,i) $(C(m,i)), z(m, i, 'm0', 'i0', li))=e= 1;
 221   
 222  cnstr_6(m,i) $(L(m,i)).. sum((li,n,j) $(D(n,j) or (sameas(n,'m0') and sameas(j,'i0'))), z(m,i,n,j,li))=e= 1 ;
 223  cnstr_7(m,i) $(D(m,i)).. sum((li,n,j) $(L(n,j) or (sameas(n,'m0') and sameas(j,'i0'))), z(m,i,n,j,li))=e= 1 ;
 224   
 225  cnstr_8(m,i,n,j,xr) $(c(m,i) and c(n,j) and (not sameas(m,n) or not sameas(i,j))).. abs(P_x(m,i,'a4',xR)- P_x(n,j,'a0',xR)) - Mnum*abs(1 - sum(li, z(m,i,n,j,li)))  =l= 0;
 226  cnstr_8_1(m,i,n,j,xr) $(c(m,i) and c(n,j)and (not sameas(m,n) or not sameas(i,j))).. abs(P_x(m,i,'a4',xR) - P_x(n,j,'a0',xR)) + Mnum*abs(1 - sum(li, z(m,i,n,j,li))) =g= 0;
 227   
 228  cnstr_9(m,i,n,j,yr) $(c(m,i) and c(n,j)and (not sameas(m,n) or not sameas(i,j))).. abs(P_Y(m,i,'a4',YR) - P_Y(n,j,'a0',yR)) - Mnum*abs(1 - sum(li, z(m,i,n,j,li)))  =l= 0;
 229  cnstr_9_1(m,i,n,j,yr) $(c(m,i) and c(n,j)and (not sameas(m,n) or not sameas(i,j))).. abs(P_Y(m,i,'a4',YR) - P_Y(n,j,'a0',yR)) + Mnum*abs(1 - sum(li, z(m,i,n,j,li))) =g= 0;
 230   
 231  cnstr_10(m,i,a) $(c(m,i)).. sum(XR, P_X(m,i,a,XR)) =e= 1;
 232  cnstr_11(m,i,a) $(c(m,i)).. sum(YR, P_Y(m,i,a,YR)) =e= 1;
 233   
 234  cnstr_12(m,i) $(L(m,i)).. sum(YL, P_Y(m,i,'a0',YL)) =e= 1;
 235  cnstr_13(m,i) $(D(m,i)).. sum(YS, P_Y(m,i,'a0',YS)) =e= 1;
 236   
 237  cnstr_14(m,i,XR) $(D(m,i) and o(m,i,XR)).. P_X(m, i,'a0',XR) =e= 1;
 238  * A_L depends on container (m,i), it needs fixing, hence cnstr_15 and cnstr_19 and A_R
 239  cnstr_15(m,i) $(L(m,i))..sum((A_L_set, A_R_set) $(ord(A_L_set) = ord(A_R_set)),sum(x_t $(x_t.val >= A_L_set.val and x_t.val<=A_R_set.val) ,P_X(m,i,'a0',x_t))) =e= 1; !!this ord shows forces the container to belong to one and only one block
 240  cnstr_19(m,i) $(D(m,i))..sum((A_L_set, A_R_set) $(ord(A_L_set) = ord(A_R_set)) ,sum(x_t $(x_t.val >= A_L_set.val and x_t.val<=A_R_set.val) ,P_X(m,i,'a3',x_t))) =e= 1;
 241   
 242  cnstr_16(m,i) $(D(m,i)).. sum(YL, P_Y(m,i,'a3',YL)) =e= 1;
 243  cnstr_17(m,i) $(L(m,i)).. sum(YS, P_Y(m,i,'a3',YS)) =e= 1;
 244  cnstr_18(m,i,XR) $(L(m,i) and o(m,i,XR)).. P_X(m, i,'a3',XR) =e= 1;
 245   
 246  cnstr_20(m, i, a1, a1_1, YR) $(WH(m,i,a1) and (ord(a1_1) = ord(a1)-1)).. P_Y(m,i,a1,YR) =e= P_Y(m,i,a1_1,YR);
 247  cnstr_21(m, i, a1, a1_1, XR) $(WV(m,i,a1) and (ord(a1_1) = ord(a1)-1))..P_X(m, i, a1, XR) =e= P_X(m,i,a1_1,XR);
 248   
 249  *******************************************************************************************************************************************************************************************
 250  ****Conflict Free Constraints
 251  cnstr_22(m,i,n,j) $(c(m,i) and c(n,j)).. U_AGV(m,i,'a4',n,j,'a1') =g= sum(li, z(m,i,n,j,li));
 252  * wt(a1_1) and wt(a2_1) are computed here!
 253  cnstr_23(m,i,a1,n,j,a2,YR,XR,a1_1,a2_1)$((ord(a1_1) = ord(a1) - 1) and (ord(a2_1) =  ord(a2) - 1) and WH(m,i,a1) and WH(n,j,a2) and (not sameas(m,n) or not sameas(i,j) or not sameas(a1,a2)))..U_AGV(m,i,a1,n,j,a2) + U_AGV(n,j,a2,m,i,a1) + 3 - P_Y(m,i,a1,YR) - P_Y(n,j,a2, YR) -(sum(XR1 $(XR1.val <= XR.val), P_X(m,i,a1_1,XR1) + P_X(n,j,a2,XR1) - P_X(m,i,a1,XR1) - P_X(n,j,a2_1,XR1))) =g= 0;
 254  *
 255  cnstr_24(m,i,n,j,a) $(C(m,i) and WH(n,j,a)).. T_Q(m,i) + G_Q(m,i) + Mnum*(1 - U_QC(m,i,n,j,a)) =g= T_start(n,j,a);
 256  cnstr_25(m,i,n,j,a1, a1_1) $(C(m,i) and WH(n,j,a1) and (ord(a1_1)=ord(a1)-1)).. T_Start(n,j,a1) + t_AGV(n,j,a1_1,n,j,a1) + Mnum*(1 - U_QC(m,i,n,j,a1) ) =g= T_Q(m,i);
 257  *
 258  *!! YS is used in here!
 259  cnstr_26(n,j,a2,YS,m,i,a1,a2_1) $( ( (sameas(a1, 'a0') and D(m,i)) or (sameas(a1, 'a3') and L(m,i)) ) and wh(n,j,a2) and (ord(a2_1)=ord(a2)-1))..(3 - U_QC(m,i,n,j,a2) - P_Y(m,i,a1,YS) - P_Y(n,j,a2,YS) +abs(sum(XR $(XR.val <= o1(m,i)), P_x(n,j,a2,XR)) - sum(XR $(XR.val > o1(m,i)), P_X(n,j,a2_1,XR)))) * Mnum +T_start(n,j,a2) + t_agv(n,j,a2_1,m,i,a1) =g= T_Q(m,i) + G_Q(m,i);
 260  cnstr_27(m,i,a1,n,j,a2,XR) $(Wv(m,i,a1) and Wv(n,j,a2) and (not sameas(m,n) or not sameas(i,j) or not sameas(a1,a2))).. U_AGV(m,i,a1,n,j,a2) + U_AGV(n,j,a2,m,i,a1) =g= P_X(m,i,a1,XR) + P_X(n,j,a2,XR) - 1;
 261  cnstr_28(m,i,a1, a1_1) $(C(m,i) and (sameas(a1,'a2') or sameas(a1,'a3') or sameas(a1,'a4')) and (ord(a1_1) = ord(a1) - 1)).. U_AGV(m,i,a1_1,m,i,a1) =e= 1;
 262   
 263  *******************************************************************************************************************************************************************************************
 264  ***Time Constraints
 265  cnstr_29(m,i,i1) $(c(m,i) and (ord(i1)=ord(i)+1) and c(m,i1)).. T_Q(m,i1) - T_Q(m,i) - G_Q(m,i) - S_Q=g= 0;
 266  cnstr_30(m,i,n,j) $(psi_1(m,i,n,j)).. T_Q(n,j) =g= T_Q(m,i) + G_Q(m,i);
 267  cnstr_31(m,i,n,j) $(psi_2(m,i,n,j)).. T_Y(n,j) =g= T_Y(m,i) +G_Y(m,i);
 268   
 269  cnstr_32(m,i) $(D(m,i)).. T_y(m,i) =g= T_start(m,i,'a3') + t_AGV(m,i,'a2',m,i,'a3');
 270  cnstr_33(m,i) $(L(m,i)).. T_Q(m,i) =g= T_start(m,i,'a3') + t_agv(m,i,'a2',m,i,'a3');
 271   
 272  cnstr_34(m,i,n,j) $(D(m,i) and L(n,j))..T_y(n,j) + Mnum*(1 - sum(li, z(m,i,n,j,li))) =g= T_start(m,i,'a4') + t_agv(m,i,'a3',m,i,'a4');
 273  cnstr_35(m,i,n,j) $(L(m,i) and D(n,j))..T_Q(n,j) + Mnum*(1 - sum(li, z(m,i,n,j,li))) =g= T_start(m,i,'a4') + t_agv(m,i,'a3',m,i,'a4');
 274   
 275  cnstr_36(m,i,a) $( (D(m,i) and sameas(a,'a4')) or (L(m,i) and sameas(a,'a1')) )..T_start(m,i,a) =g= t_y(m,i) + G_y(m,i);
 276  cnstr_37(m,i,a) $( (D(m,i) and sameas(a,'a1')) or (L(m,i) and sameas(a,'a4')) )..T_start(m,i,a) =g= t_Q(m,i) + G_Q(m,i);
 277  cnstr_38(m,i,a1,a1_1,n,j,a2) $(WT(m,i,a1) and wt(n,j,a2) and (ord(a1_1) = ord(a1)-1) and (not sameas(m,n) or not sameas(i,j) or not sameas(a1,a2))).. T_start(n,j,a2) + Mnum*(1-U_AGV(m,i,a1,n,j,a2)) =g= T_start(m,i,a1) + t_AGV(m,i,a1_1,m,i,a1);
 278   
 279  * THE BIG-M TRICK FOR IF-CONDITIONAL
 280  cnstr_39(m,i,a,XR) $(C(m,i)).. x_position(m,i,a) - XR.val - Mnum *abs(1-P_X(m,i,a,XR)) =l= 0;
 281  cnstr_39_1(m,i,a,XR) $(C(m,i)).. x_position(m,i,a) - XR.val + Mnum *abs(1-P_X(m,i,a,XR)) =g= 0;
 282  cnstr_40(m,i,a,YR) $(C(m,i)).. y_position(m,i,a) - YR.val  -Mnum *abs(1-P_Y(m,i,a,YR)) =l= 0;
 283  cnstr_40_1(m,i,a,YR) $(C(m,i))..  y_position(m,i,a) - YR.val  +Mnum *abs(1-P_Y(m,i,a,YR)) =g= 0;
 284  ****************************************
 285  * Just writing the switch time between actions according the position of the start and finish locaiton of the action and AGVs next aciton
 286  *and the speed of the vehicle which is constant. Which might be bad!!
 287  cnstr_41(m,i,a1,n,j,a2) $(c(m,i) and c(n,j)).. t_agv(m,i,a1,n,j,a2) - (abs(x_position(m,i,a1) - x_position(n,j,a2)) + abs(Y_position(m,i,a1) - y_position(n,j,a2)))/v =e= 0;
 288  ****************************************
 289   
 290  Model ConflictFreeSch /all/ ;
 291  option SOLVER = Gurobi;
 292   
 293  * This is for detecting a set of Irredicuible Infeasible Solutions; Gurobi-specific:
 294  *$onEcho > CFS.opt
 295  *iis 1
 296  *indic cnstr_8(m,i,n,j,XR)$slack(m,i,n,j) 1
 297  *$offEcho
 298  *ConflictFreeSch.Optfile = 1;
 299  solve conflictfreesch using MINLP min obj;
 300   
 301   
 302   
 303   
 304  *Option MIP = COPT;
 305  *Model ConflictFreeSch /adrp3, cnstr_2, cnstr_3, cnstr_4, cnstr_5, cnstr_6, cnstr_7/ ;
 306  *Solve ConflictFreeSch using mip minimizing slack1;
 307  *display z.l;
 308  *Solve ConflictFreeSch using mip minimizing slack1;
 309  *display z.l;
 310  *$gdxout BBAPP
 311  *$unload
 312  *$gdxout
 313  *Display x.l, x.m ;
 314   
 315   
 316   
 317   
 318   
 319   
 320   
 321   
 322   
 323   
 324   
 325   
 326   
 327   
 328   
 329   
 330   
 331   
 332   
 333   
 334   
 335   
 336   
 337   
 338   
 339   
 340   
 341   
 342   
 343   
 344   
 345   
 346   
 347   
 348   
 349   
 350   
 351   
 352   
 353   
 354   
 355   
 356   
 357   
 358   
 359   
 360   
 361   
 362   
 363   
 364   
 365   
 366   
 367   
 368   
 369   
 370   
 371   
 372   
 373   
 374   
 375   
 376   
 377   
 378   
 379   
 380   
 381   
 382   


COMPILATION TIME     =        0.000 SECONDS      3 MB  48.6.1 67fbb04b WEX-WEI


USER: GAMS Demo, for EULA and demo limitations see   G241001/0001CB-GEN
      https://www.gams.com/latest/docs/UG%5FLicense.html         DC0000


**** FILE SUMMARY

Input      C:\Users\Asus\Projects\FrequentlyUsedRepos\AGV-Project\Thesis\Implementation\BBAPP.gms
Output     C:\Users\Asus\Projects\FrequentlyUsedRepos\AGV-Project\Thesis\Implementation\BBAPP.lst
XSave      C:\Users\Asus\Projects\FrequentlyUsedRepos\AGV-Project\Thesis\Implementation\BBAPP.g0?

**** WARNING - COMPILER OPTIONS ARE NON DEFAULT     ONEMPTY
